BITS 64
DEFAULT REL

%define MEM_COMMIT	 0x1000
%define MEM_RESERVE  0x2000
%define MEM_RESET	0x80000

%define MEM_LARGE_PAGES		0x20000000
%define MEM_PHYSICAL		  0x400000
%define MEM_TOP_DOWN		  0x100000
%define MEM_WRITE_WATCH		  0x200000

%define PAGE_NOACCESS			0x01
%define PAGE_READONLY			0x02
%define PAGE_READWRITE			0x04
%define PAGE_WRITECOPY			0x08
%define PAGE_EXECUTE			0x10
%define PAGE_EXECUTE_READ		0x20
%define	PAGE_EXECUTE_READWRITE	0x40
%define PAGE_EXECUTE_WRITECOPY	0x80

%define PAGE_GUARD				0x100
%define PAGE_NOCACHE			0x200
%define PAGE_WRITECOMBINE		0x400

global UnloadSelfAndExit
extern VirtualAlloc,GetProcAddress,GetModuleHandleA

section .text

;; extern "C" VOID __fastcall UnloadSelfAndExit(HMODULE hModule);
struc UnloadSelfAndExitShadowSpace
	.hModule	resq	1
endstruc

UnloadSelfAndExit:
	mov [rsp+UnloadSelfAndExitShadowSpace.hModule], rcx
	xor rcx, rcx
	mov rdx, unload_self_size+unload_self_config_size
	
	xor r8,r8
	or r8, MEM_COMMIT
	or r8, MEM_RESERVE

	xor r9,r9
	or r9, PAGE_EXECUTE_READWRITE

	sub rsp, 20h
	call VirtualAlloc
	add rsp, 20h

	mov rbx, rax

	mov rdi, rax
	lea rsi, [unload_self]
	mov rcx, unload_self_size
	rep movsb
	mov rbx, rdi

	lea rcx, [cKernel32]
	lea rdx, [cFreeLibrary]

	sub rsp, 20h
	call helperGetProcAddress
	add rsp, 20h

	mov [rbx + unload_self_config.fpFreeLibrary],rax

	lea rcx, [cKernel32]
	lea rdx, [cExitThread]

	sub rsp, 20h
	call helperGetProcAddress
	add rsp, 20h

	mov [rbx + unload_self_config.fpExitThread],rax

	mov rcx, [rsp+UnloadSelfAndExitShadowSpace.hModule]
	mov [rbx + unload_self_config.hModule], rcx

	lea rax, [rbx - unload_self_size]
	jmp rax

;; __fastcall helperGetProcAddress(char *moduleName, char *functionName)
helperGetProcAddress:
	;Stack alignment
	sub rsp, 8h

	mov [rsp], rdx
	sub rsp,20h
	call GetModuleHandleA
	add rsp, 20h

	mov rcx, rax
	mov rdx, [rsp]
	sub rsp, 20h
	call GetProcAddress
	add rsp, 20h

	;Stack alignment
	add rsp, 8h
	ret

cKernel32: db "Kernel32.dll",0
cFreeLibrary: db "FreeLibrary",0
cExitThread: db "ExitThread",0

struc unload_self_config
	.hModule			resq	1
	.fpExitThread		resq	1
	.fpFreeLibrary	resq	1
endstruc

unload_self:
	jmp .a
.b:
	pop rbp
	
	;FreeLibrary(hModule)
	mov rcx, [rbp+unload_self_config.hModule]
	mov rax, [rbp+unload_self_config.fpFreeLibrary]

	sub rsp, 28h
	call rax
	add rsp, 28h

	;ExitThread(0)

	xor rcx,rcx
	mov rax, [rbp+unload_self_config.fpExitThread]
	
	sub rsp, 20h
	call rax ; Never actually returns.
	add rsp, 20h
	
	ret
.a:
	call .b

unload_self_size: equ $-unload_self
; We're pretending there is an unload_self_config struc here...